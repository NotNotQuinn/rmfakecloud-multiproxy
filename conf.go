package main

import (
	"errors"
	"flag"
	"fmt"
	"net/url"
	"os"
	"path/filepath"
	"strings"
)

type ConfigFile map[string]string

func (cfg *ConfigFile) Get(key string) string {
	return (*cfg)[key]
}
func (cfg *ConfigFile) Set(key string, value string) {
	(*cfg)[key] = value
}

// Returns multi-line error messages as string
// and if the config is valid.
func (cfg *ConfigFile) Validate(ignoreRequired bool) (string, bool) {
	errors := ""
	isValid := true

	if !ignoreRequired {
		// Check for required keys
		required_keys := []string{
			"PROXY_LISTEN_ADDR",
			"TLS_CERTIFICATE_FILE",
			"TLS_KEY_FILE",
		}
		mode_keys := []string{
			"UPSTREAM_CLOUD_URL",
			"USE_OFFICIAL_CLOUD",
		}

		// Check required keys
		for _, key := range required_keys {
			if !cfg.IsSet(key) {
				isValid = false
				if errors == "" {
					errors += "cfg: All of the following must be set:\n"
				}
				errors += "cfg:   " + key + "\n"
			}
		}

		has_mode := false
		for _, key := range mode_keys {
			if cfg.IsSet(key) {
				has_mode = true
			}
		}

		if !has_mode {
			isValid = false
			errors += "cfg: One of the following must be set:\n"
			for _, key := range mode_keys {
				errors += "cfg:   " + key + "\n"
			}
		}
	}

	for key, option := range validOptions {
		val := cfg.Get(key)

		switch option.Validation {
		case validateBool:
			if val != "true" && val != "false" {
				isValid = false
				errors += "cfg: " + key + " must be either 'true' or 'false'\n"
				errors += "cfg:   Current value: '" + val + "'\n"
			}
		case validateURL:
			_, err := url.Parse(val)
			if err != nil {
				isValid = false
				errors += "cfg: " + key + " has an invalid URL\n"
				errors += "cfg:   " + fmt.Sprintf("%v", err) + "\n"
			}
		case validateString:
			// No validation needed
		case validateUnset:
			isValid = false
			errors += "cfg: " + key + " has no validation type\n"
			errors += "cfg:   This can only be fixed by a new release\n"
			errors += "cfg:   Please create an issue about this on on github\n"
		default:
			isValid = false
			errors += "cfg: " + key + " has unknown validation type\n"
			errors += "cfg:   This can only be fixed by a new release\n"
			errors += "cfg:   Please create an issue about this on on github\n"
		}
	}

	for key := range *cfg {
		_, exists := validOptions[key]
		if !exists {
			isValid = false
			errors += "cfg: " + key + ": unknown option\n"
		}
	}

	if !isValid {
		errors += "cfg:\n"
		errors += "cfg: See `rmfakecloud-multiproxy --docs` for config documentation\n"
	}
	return errors, isValid
}

// Returns if key is set. Empty string doesn't count.
//
// If key is validated as a boolean, returns true
// only if value is "true".
func (cfg *ConfigFile) IsSet(key string) bool {
	val, exists := (*cfg)[key]
	if !exists || val == "" {
		return false
	}

	opt, exists := validOptions[key]
	if !exists {
		// how did that happen?
		// I guess its technically set.
		// But its certainly not valid!
		return false
	}

	switch opt.Validation {
	case validateBool:
		return val == "true"
	default:
		return true
	}
}

type validationStrategy int

const (
	// unset is invalid
	validateUnset  validationStrategy = 0
	validateBool   validationStrategy = 1
	validateString validationStrategy = 2
	validateURL    validationStrategy = 3
)

type configOption struct {
	Default       *string
	Documentation []string
	Validation    validationStrategy
}

func strptr(s string) *string {
	return &s
}

var validOptions = map[string]configOption{
	"TLS_CERTIFICATE_FILE": {
		Default: nil, Documentation: []string{
			"TLS certificate file (.crt) that was generated by rmfakecloudctl.",
			"Certificates are self-signed, so they must be installed on the system",
			"else they will be untrusted.",
		},
		Validation: validateString,
	},
	"TLS_KEY_FILE": {
		Default: nil, Documentation: []string{
			"TLS key file (.key) that was generated by rmfakecloudctl.",
		},
		Validation: validateString,
	},
	"PROXY_LISTEN_ADDR": {
		Default: nil, Documentation: []string{
			"Address to listen for TCP connections.",
			"rmfakecloudctl patches /etc/hosts for 127.0.42.10",
			"so you likely want that. Do not include a port.",
		},
		Validation: validateString,
	},
	"UPSTREAM_CLOUD_URL": {
		Default: strptr(""), Documentation: []string{
			"Upstream rmfakecloud instance to proxy traffic towards.",
			"Ignored if USE_OFFICIAL_CLOUD=true.",
		},
		Validation: validateURL,
	},
	"LOG_HTTP_REQUESTS": {
		Default: strptr("false"), Documentation: []string{
			"Logs network requests and responses.",
			"Works for rmfakecloud instances and the official cloud.",
			"Boolean `true` or `false`",
		},
		Validation: validateBool,
	},
	"USE_OFFICIAL_CLOUD": {
		Default: strptr("false"), Documentation: []string{
			"Pass requests through to the correct destination.",
			"Boolean `true` or `false`",
		},
		Validation: validateBool,
	},
}

var (
	ErrInvalidConfigFormat = errors.New("invalid config: must be of the form 'OPTION=VALUE'")
)

// Applies the changes of a line of the config.
//
// Valid lines:
//   - Lines starting with '#'
//   - Blank lines
//   - OPTION=VALUE lines where both OPTION and VALUE are valid
func (cfg *ConfigFile) ApplyLine(line string) error {
	line = strings.TrimRight(line, "\t ")
	if len(line) == 0 {
		return nil
	}
	if line[0] == '#' {
		return nil
	}

	split := strings.Split(line, "=")
	if len(split) < 2 {
		return ErrInvalidConfigFormat
	}

	key := split[0]
	value := strings.Join(split[1:], "=")

	cfg.Set(key, value)
	return nil
}

// Applies defaults from `configDocs` to config
// via `cfg.ApplyLine`
func newConfig() ConfigFile {
	cfg := ConfigFile{}

	for name, doc := range validOptions {
		if doc.Default != nil {
			cfg.ApplyLine(name + "=" + *doc.Default)
		}
	}

	return cfg
}

func printCliUsage() {
	usage := "usage: %[1]s [--validate] [--ignore-required] [-c config] [-C OPTION=VALUE]...\n"
	usage += "       %[1]s [-h] [-v] [--help] [--version] [--docs]\n"
	usage += "  -C OPTION=VALUE\n"
	usage += "        Explicitly set OPTION=VALUE\n"
	usage += "        Usable multiple times\n"
	usage += "  -c config\n"
	usage += "        Load options from config file\n"
	usage += "  --ignore-required\n"
	usage += "        Do not fail validation when required options are unset\n"
	usage += "        Fails without --validate\n"
	usage += "\n"
	usage += "Early-exit options:\n"
	usage += "  --validate\n"
	usage += "        Exit after all configs are loaded and validated\n"
	usage += "  --docs\n"
	usage += "        Print documentation for config options and exit\n"
	usage += "  -h, --help\n"
	usage += "        Print this help message and exit\n"
	usage += "  -v, --version\n"
	usage += "        Print version and exit\n"
	fmt.Fprintf(os.Stdout, usage, filepath.Base(os.Args[0]))
}

func genDocs() string {
	doc := "# rmfakecloud-multiproxy config documentation\n"
	doc += "# Run `rmfakecloud-multiproxy --docs` to generate this file.\n"
	doc += "# These docs also happen to be a valid config file that\n"
	doc += "# includes all options with default values.\n"
	doc += "\n"
	doc += "# No code expects the config to have these comments in it, you\n"
	doc += "# may delete them freely. They won't be regenerated.\n"
	doc += "\n"
	doc += "# Note: Most of the time, `rmfakecloudctl` will generate\n"
	doc += "# and populate the required fields for you after generating\n"
	doc += "# certs when you run `rmfakecloudctl enable`.\n"
	doc += "\n"
	doc += "# Syntax:\n"
	doc += "#   KEY=VALUE trailing tabs and spaces trimmed\n"
	doc += "#   Comments use '#' as first character on line\n"
	doc += "#   Blank lines allowed\n"
	doc += "\n"
	doc += "# Documentation:\n"
	for name, opt := range validOptions {
		doc += "\n"
		doc += "# " + strings.Join(opt.Documentation, "\n# ") + "\n"
		doc += name + "="
		if opt.Default != nil {
			doc += *opt.Default
		} else {
			doc += "!!must be set explicitly"
		}
		doc += "\n"
	}

	return doc
}

func getConfig() (config *ConfigFile, err error) {
	cfg := newConfig()

	var (
		configFile     string
		getDocs        bool
		getUsage       bool
		getVersion     bool
		validateConfig bool
		ignoreRequired bool
		explicitConfig []string
	)

	flag.Func("C", "", func(s string) error {
		if s == "" {
			return ErrInvalidConfigFormat
		}
		explicitConfig = append(explicitConfig, s)
		return nil
	})
	flag.StringVar(&configFile, "c", "", "")
	flag.BoolVar(&getDocs, "docs", false, "")
	flag.BoolVar(&validateConfig, "validate", false, "")
	flag.BoolVar(&ignoreRequired, "ignore-required", false, "")
	flag.BoolVar(&getVersion, "v", false, "")
	flag.BoolVar(&getVersion, "version", false, "")
	flag.BoolVar(&getUsage, "h", false, "")
	flag.BoolVar(&getUsage, "help", false, "")
	flag.Usage = printCliUsage

	flag.Parse()

	if getUsage {
		flag.Usage()
		os.Exit(0)
	}
	if getVersion {
		fmt.Fprintln(os.Stdout, Version)
		os.Exit(0)
	}
	if getDocs {
		doc := genDocs()
		fmt.Fprint(os.Stdout, doc)
		os.Exit(0)
	}

	if configFile != "" {
		content, err := os.ReadFile(configFile)
		if err != nil {
			return nil, fmt.Errorf("read file %q: %w", configFile, err)
		}

		for lineno, line := range strings.Split(string(content), "\n") {
			err := cfg.ApplyLine(line)
			if err != nil {
				return nil, fmt.Errorf("parse %q: line %d: %q: %w", configFile, lineno+1, line, err)
			}
		}
	}

	for n, line := range explicitConfig {
		err := cfg.ApplyLine(line)
		if err != nil {
			return nil, fmt.Errorf("parse \"-C\": %d: %q: %w", n+1, line, err)
		}
	}

	if validateConfig {
		if errors, isValid := cfg.Validate(ignoreRequired); !isValid {
			fmt.Fprint(os.Stderr, errors)
			fmt.Fprintln(os.Stderr, "Config validation failed")
			os.Exit(1)
		} else {
			fmt.Fprintln(os.Stderr, "Config validation passed")
			os.Exit(0)
		}
	}

	if ignoreRequired && !validateConfig {
		fmt.Fprintln(os.Stderr, "FATAL: --ignore-required used without --validate")
		os.Exit(1)
	}

	if errors, isValid := cfg.Validate(false); !isValid {
		errors += "FATAL: configuration validation failed\n"
		fmt.Fprint(os.Stderr, errors)
		os.Exit(1)
	}

	return &cfg, nil
}
