package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"strings"
)

// See documentation in configDocs
type ConfigFile struct {
	TLSCertificateFile string `cfg:"TLS_CERTIFICATE_FILE"`
	TLSKeyFile         string `cfg:"TLS_KEY_FILE"`
	ProxyListenAddr    string `cfg:"PROXY_LISTEN_ADDR"`
	UpstreamCloudURL   string `cfg:"UPSTREAM_CLOUD_URL"`
	LogHTTP            bool   `cfg:"LOG_HTTP_REQUESTS"`
	UseOfficialCloud   bool   `cfg:"USE_OFFICIAL_CLOUD"`
}

type configDoc struct {
	Name          string
	Default       *string
	Documentation []string
}

func strptr(s string) *string {
	return &s
}

var configDocs = []configDoc{
	{Name: "TLS_CERTIFICATE_FILE",
		Default: nil, Documentation: []string{
			"TLS certificate file (.crt) that was generated by rmfakecloudctl.",
			"Certificates are self-signed, so they must be installed on the system",
			"else they will be untrusted.",
		},
	},
	{Name: "TLS_KEY_FILE",
		Default: nil, Documentation: []string{
			"TLS key file (.key) that was generated by rmfakecloudctl.",
		},
	},
	{Name: "PROXY_LISTEN_ADDR",
		Default: nil, Documentation: []string{
			"Address to listen for TCP connections.",
			"rmfakecloudctl patches /etc/hosts for 127.0.42.10",
			"so you likely want that. Do not include a port.",
		},
	},
	{Name: "UPSTREAM_CLOUD_URL",
		Default: strptr(""), Documentation: []string{
			"Upstream rmfakecloud instance to proxy traffic towards.",
			"Ignored if USE_OFFICIAL_CLOUD=true.",
		},
	},
	{Name: "LOG_HTTP_REQUESTS",
		Default: strptr("false"), Documentation: []string{
			"Logs network requests and responses.",
			"Works for rmfakecloud instances and the official cloud.",
			"Boolean `true` or `false`",
		},
	},
	{Name: "USE_OFFICIAL_CLOUD",
		Default: strptr("false"), Documentation: []string{
			"Pass requests through to the correct destination.",
			"Boolean `true` or `false`",
		},
	},
}

func parseBool(b *bool, s string) error {
	switch s {
	case "true":
		*b = true
	case "false":
		*b = false
	default:
		return ErrInvalidBoolean
	}
	return nil
}

var (
	ErrInvalidConfigFormat = errors.New("invalid config: must be of the form 'OPTION=VALUE'")
	ErrUnknownConfigOption = errors.New("unknown config option")
	ErrInvalidBoolean      = errors.New("invalid boolean: only 'true' or 'false' are accepted")
)

// Applies the changes of a line of the config.
//
// Valid lines:
//   - Lines starting with '#'
//   - Blank lines
//   - OPTION=VALUE lines where both OPTION and VALUE are valid
func (cfg *ConfigFile) ApplyLine(line string) error {
	line = strings.TrimRight(line, "\t ")
	if len(line) == 0 {
		return nil
	}
	if line[0] == '#' {
		return nil
	}

	split := strings.Split(line, "=")
	if len(split) < 2 {
		return ErrInvalidConfigFormat
	}

	key := split[0]
	value := strings.Join(split[1:], "=")

	switch key {
	case "TLS_CERTIFICATE_FILE":
		cfg.TLSCertificateFile = value
	case "TLS_KEY_FILE":
		cfg.TLSKeyFile = value
	case "BIND_ADDRESS":
		cfg.ProxyListenAddr = value
	case "UPSTREAM_CLOUD_URL":
		cfg.UpstreamCloudURL = value
	case "LOG_HTTP_REQUESTS":
		err := parseBool(&cfg.LogHTTP, value)
		if err != nil {
			return err
		}
	case "USE_OFFICIAL_CLOUD":
		err := parseBool(&cfg.UseOfficialCloud, value)
		if err != nil {
			return err
		}
	default:
		return ErrUnknownConfigOption
	}

	return nil
}

// Applies defaults from `configDocs` to config
// via `cfg.ApplyLine`
func newConfig() ConfigFile {
	cfg := ConfigFile{}

	if reflect.TypeOf(cfg).NumField() != len(configDocs) {
		fmt.Fprintln(os.Stderr, "number of fields on ConfigFile do not match length of documented fields")
		fmt.Fprintln(os.Stderr, "\\=== Fix this")
		os.Exit(1)
	}

	for _, doc := range configDocs {
		if doc.Default != nil {
			cfg.ApplyLine(doc.Name + "=" + *doc.Default)
		}
	}

	return cfg
}

func getConfig() (config *ConfigFile, err error) {
	cfg := newConfig()

	var (
		configFile     string
		getDocs        bool
		getUsage       bool
		getVersion     bool
		explicitConfig []string
	)

	flag.Func("C", "", func(s string) error {
		if s == "" {
			return ErrInvalidConfigFormat
		}
		explicitConfig = append(explicitConfig, s)
		return nil
	})
	flag.StringVar(&configFile, "c", "", "")
	flag.BoolVar(&getDocs, "docs", false, "")
	flag.BoolVar(&getVersion, "v", false, "")
	flag.BoolVar(&getVersion, "version", false, "")
	flag.BoolVar(&getUsage, "h", false, "")
	flag.BoolVar(&getUsage, "help", false, "")
	flag.Usage = func() {
		usage := "usage: %[1]s [-c config] [-C OPTION=VALUE]...\n"
		usage += "       %[1]s [-h] [-v] [--help] [--version] [--docs]\n"
		usage += "  -C OPTION=VALUE\n"
		usage += "        Explicitly set OPTION=VALUE\n"
		usage += "        Usable multiple times\n"
		usage += "  -c config\n"
		usage += "        Load options from config file\n"
		usage += "\n"
		usage += "Early-exit options:\n"
		usage += "  --docs\n"
		usage += "        Print documentation for config options and exit\n"
		usage += "  -h, --help\n"
		usage += "        Print this help message and exit\n"
		usage += "  -v, --version\n"
		usage += "        Print version and exit\n"
		fmt.Fprintf(os.Stdout, usage, filepath.Base(os.Args[0]))
	}

	flag.Parse()

	if getUsage {
		flag.Usage()
		os.Exit(0)
	}
	if getVersion {
		fmt.Fprintln(os.Stdout, Version)
		os.Exit(0)
	}
	if getDocs {
		doc := "# rmfakecloud-multiproxy config documentation\n"
		doc += "# Run `rmfakecloud-multiproxy --docs` to generate this file.\n"
		doc += "# These docs also happen to be a valid config file that\n"
		doc += "# includes all options with default values.\n"
		doc += "\n"
		doc += "# No code expects the config to have these comments in it, you\n"
		doc += "# may delete them freely. They won't be regenerated."
		doc += "\n"
		doc += "# Note: Most of the time, `rmfakecloudctl` will generate\n"
		doc += "# and populate the config for you after generating certs\n"
		doc += "# in `rmfakecloudctl enable`.\n"
		doc += "\n"
		doc += "# Syntax:\n"
		doc += "#   KEY=VALUE trailing tabs and spaces trimmed\n"
		doc += "#   Comments use '#' as first character on line\n"
		doc += "#   Blank lines allowed\n"
		doc += "\n"
		doc += "# All valid keys (machine readable):\n"
		for _, option := range configDocs {
			doc += "#   valid-key: " + option.Name + "\n"
		}
		doc += "\n"
		doc += "# Documentation:\n"
		for _, option := range configDocs {
			doc += "\n"
			doc += "# " + strings.Join(option.Documentation, "\n# ") + "\n"
			doc += option.Name + "="
			if option.Default != nil {
				doc += *option.Default
			} else {
				doc += "!!must be set explicitly"
			}
			doc += "\n"
		}
		fmt.Fprint(os.Stdout, doc)
		os.Exit(0)
	}

	if configFile != "" {
		content, err := os.ReadFile(configFile)
		if err != nil {
			return nil, err
		}

		for _, line := range bytes.Split(content, []byte{'\n'}) {
			err := cfg.ApplyLine(string(line))
			if err != nil {
				return nil, err
			}
		}
	}

	for _, line := range explicitConfig {
		err := cfg.ApplyLine(line)
		if err != nil {
			return nil, err
		}
	}

	return &cfg, nil
}
