#!/usr/bin/env bash
# Copyright (c) 2021 ddvk
# Copyright (c) 2021 The Toltec Contributors
# Copyright (c) 2023 QuinnDT
# SPDX-License-Identifier: MIT

set -euo pipefail

# Path where the certificate authority key and proxy TLS certificate are stored
data_dir=/opt/var/rmfakecloud-multiproxy

# Path where system CA certificates are stored
local_cert_dir=/usr/local/share/ca-certificates

# Path to the static hosts definition
hosts_path=/etc/hosts

# Path to the configuration directory
conf_dir=/opt/etc/rmfakecloud-multiproxy

# Proxy listen address
proxy_listen=127.0.42.10

# Path to the Xochitl configuration file
xochitl_conf_path=/home/root/.config/remarkable/xochitl.conf

# Path to Xochitl data
xochitl_data_dir=/home/root/.local/share/remarkable/xochitl

# ANSI escapes for colors
red="\033[31m"
green="\033[32m"
yellow="\033[33m"
reset="\033[m"

# ANSI escape to clear line from cursor until end
clearline="\033[K"

# Disconnect Xochitl from the cloud
#
# This is a necessary step when switching cloud servers to prevent the client
# from believing all the files have been deleted.
disconnect-cloud() {
    if grep -q "^devicetoken=" "$xochitl_conf_path" \
        && grep -q "^usertoken=" "$xochitl_conf_path"; then
        echo "Xochitl sync is enabled. Disabling..."
    else
        return 0
    fi

    # Make sure Xochitl is not running
    local was_active=

    if systemctl --quiet is-active xochitl.service 2> /dev/null; then
        systemctl stop xochitl
        was_active=1
    fi

    local xochitl_pid=

    if xochitl_pid="$(pgrep --exact --oldest xochitl)"; then
        kill "$xochitl_pid"
        echo "Waiting for Xochitl to stop"
        local xochitl_wait_count=0

        while kill -0 "$xochitl_pid" 2> /dev/null; do
            sleep 1
            xochitl_wait_count=$((xochitl_wait_count++))

            if ((xochitl_wait_count > 5)); then
                echo "Force killing Xochitl"
                kill -9 "$xochitl_pid"
            fi
        done
    fi

    # Mark all files as not synced
    grep sync "$xochitl_data_dir"/*.metadata -l \
        | xargs sed -i 's/synced\": true/synced\": false/'

    # Disconnect from cloud
    sed -i '/^devicetoken=/d' "$xochitl_conf_path"
    sed -i '/^usertoken=/d' "$xochitl_conf_path"

    # Re-enable Xochitl service if it was running
    if [[ -n $was_active ]]; then
        systemctl start xochitl
    fi
}

# Validate the config is correct.
#
# Exit code:
#  0 - config is valid
#  1 - config is not valid
validate-config() {
    rmfakecloud-multiproxy --validate -c "$conf_dir/config"
}

# Check if the proxy has been enabled
#
# Exit code:
#
# 0 - If the proxy is enabled
# Other - If the proxy is disabled
is-enabled() {
    [[ -f "$conf_dir/enabled" ]]
}

mark-enabled() {
    mkdir -p "$conf_dir"
    touch "$conf_dir/enabled"
}

mark-disabled() {
    rm -f "$conf_dir/enabled"
}

# Set an option in the config file, overwriting what was there beforehand.
# If no config file exists, the default is generated before the key is set.
# Does not handle shorthands.
#
# Arguments:
#  $1 - Option key
#  $2 - Value
#
# Exit codes:
#  0 - success
#  1 - invalid key
#  2 - invalid value
#  3 - unsupported (but valid) value
set-config() {
    local key=$1
    local value=$2
    if [[ ! -e "$conf_dir/config" ]]; then
        generate-default-config
    fi

    if ! rmfakecloud-multiproxy --docs | grep "^\w" | cut -f1 -d"=" | grep -Fxq "$key";
    then
        echo "$key: invalid key"
        return 1
    fi

    if ! rmfakecloud-multiproxy --validate --ignore-required -C "$key=$value" 1>/dev/null;
    then
        return 2
    fi

    case "$key" in
    *"|"*)
        echo "Value '$value' contains the pipe character ('|') which is"
        echo "unsupported by \`multiproxyctl\` for technical reasons."
        echo "To set this value, please edit the config file directly."
        echo "config: $conf_dir/config"
        return 3
    ;;
    esac

    echo "$key=$value"

    # If key does not exist in the config file
    if ! grep "^\w" "$conf_dir/config" | cut -f1 -d"=" | grep -Fxq "$key"; then
        echo "$key=$value" >> "$conf_dir/config"
    else
        # These are the afformentioned technical reasons.
        # Value cannot contain pipe
        sed -i "/^$key/s|=.*$|=$value|" "$conf_dir/config"
    fi
}

# Read the config. Does not handle shorthands.
#
# Output: Value set for config
#
# Arguments:
#  $1 - Key to read
#
# Exit code:
#  0 - If the key is set (even if empty)
#  1 - If the key is not set
get-config() {
    local key=$1
    local value
    if [[ ! -e "$conf_dir/config" ]]; then
        return 1
    fi

    if ! value=$(grep "^$key=" "$conf_dir/config" | cut -f2 -d"="); then
        return 1
    fi

    echo "$value"
}

# Generate the default config
generate-default-config() {
    echo "Generating default config..."
    if [[ -e "$conf_dir/config" ]]; then
        cp -v "$conf_dir/config" "$conf_dir/config.bak"
    fi

    mkdir -vp "$conf_dir"
    rmfakecloud-multiproxy --docs > "$conf_dir/config"

    set-config "TLS_CERTIFICATE_FILE" "$data_dir/rmfakecloud-multiproxy.bundle.crt"
    set-config "TLS_KEY_FILE" "$data_dir/rmfakecloud-multiproxy.key"
    set-config "PROXY_LISTEN_ADDR" "$proxy_listen"
}

# Check if a given server is an rmfakecloud host
#
# Output: Details on the given host status
# Exit code:
#
# 0 - If the server seems to be a valid rmfakecloud host
# 1 - If itâ€™s definitely not
check-upstream() {
    local url="$upstream/service/json/1/test"
    local contents
    local wget_exit
    contents="$(wget \
        --output-document - \
        --quiet "$url" \
        --tries 1 \
        --timeout 5 2>&1)" && wget_exit=$? || wget_exit=$?

    if [[ $wget_exit = 8 ]]; then
        # HTTP error, the page probably doesn't exist
        echo "invalid"
        return 1
    elif [[ $wget_exit = 4 ]]; then
        # Network error, the server probably doesn't exist or is offline
        echo "unreachable"
        return 1
    elif [[ $wget_exit != 0 ]]; then
        # Other error
        echo "error"
        return 1
    fi

    if [[ $contents != '{"Host":"local.appspot.com","Status":"OK"}' ]]; then
        echo "invalid"
        return 1
    fi

    echo "working"
    return 0
}

# Generate a local certificate authority, add it to the system trust,
# and create a self-signed proxy certificate
install-certificates() {
    mkdir -p "$data_dir" "$local_cert_dir"

    if [[ ! -f $data_dir/rmfakecloud-ca.key ]] \
        || [[ ! -f $data_dir/rmfakecloud-ca.crt ]]; then
        openssl genrsa -out "$data_dir/rmfakecloud-ca.key" 2048
        openssl req -new -sha256 -x509 \
            -key "$data_dir/rmfakecloud-ca.key" \
            -out "$data_dir/rmfakecloud-ca.crt" \
            -days 3650 -subj /CN=rmfakecloud-ca
        rm -f "$data_dir/rmfakecloud-multiproxy.key"
    fi

    if ! cmp -s {"$data_dir","$local_cert_dir"}/rmfakecloud-ca.crt; then
        cp -f "$data_dir/rmfakecloud-ca.crt" "$local_cert_dir"
        update-ca-certificates --fresh
    fi

    if [[ ! -f $data_dir/rmfakecloud-multiproxy.key ]]; then
        openssl genrsa -out "$data_dir/rmfakecloud-multiproxy.key" 2048
        rm -f "$data_dir/rmfakecloud-multiproxy.pubkey"
    fi

    if [[ ! -f $data_dir/rmfakecloud-multiproxy.pubkey ]]; then
        openssl rsa -in "$data_dir/rmfakecloud-multiproxy.key" -pubout \
            -out "$data_dir/rmfakecloud-multiproxy.pubkey"
        rm -f "$data_dir/rmfakecloud-multiproxy.crt"
    fi

    if [[ ! -f $data_dir/rmfakecloud-multiproxy.crt ]]; then
        local csr
        csr="$(mktemp)"

        cat >> "$csr" << CSR
[ req ]
default_bits = 2048
default_keyfile = proxy.key
encrypt_key = no
default_md = sha256
prompt = no
utf8 = yes
distinguished_name = dn
req_extensions = ext
x509_extensions = caext
[ dn ]
C = AA
ST = QQ
L = JJ
O  = the culture
CN = *.appspot.com
[ ext ]
subjectAltName=@san
basicConstraints=CA:FALSE
subjectKeyIdentifier = hash
[ caext ]
subjectAltName=@san
[ san ]
DNS.1 = *.appspot.com
DNS.2 = *.cloud.remarkable.com
DNS.3 = *.remarkable.com
DNS.4 = *.cloud.remarkable.engineering
CSR

        openssl req -new -config "$csr" \
            -key "$data_dir/rmfakecloud-multiproxy.key" \
            -out "$data_dir/rmfakecloud-multiproxy.csr"
        openssl x509 -req -in "$data_dir/rmfakecloud-multiproxy.csr" \
            -out "$data_dir/rmfakecloud-multiproxy.crt" \
            -CA "$data_dir/rmfakecloud-ca.crt" \
            -CAkey "$data_dir/rmfakecloud-ca.key" -CAcreateserial \
            -days 3650 -extfile "$csr" -extensions caext
        rm -f "$data_dir/rmfakecloud-multiproxy.csr"
    fi

    if [[ ! -f $data_dir/rmfakecloud-multiproxy.bundle.crt ]]; then
        cat "$data_dir/rmfakecloud-multiproxy.crt" "$data_dir/rmfakecloud-ca.crt" \
            > "$data_dir/rmfakecloud-multiproxy.bundle.crt"
    fi
}

# Erase and untrust the local certificate authority
uninstall-certificates() {
    rm -f "$data_dir"/*

    if [[ -f "$local_cert_dir/rmfakecloud-ca.crt" ]]; then
        rm "$local_cert_dir/rmfakecloud-ca.crt"
        update-ca-certificates --fresh
    fi
}

# Add entries in the static host file to redirect cloud requests to the proxy
install-hosts() {
    uninstall-hosts
    cat << EOF >> "$hosts_path"
$proxy_listen hwr-production-dot-remarkable-production.appspot.com
$proxy_listen service-manager-production-dot-remarkable-production.appspot.com
$proxy_listen local.appspot.com
$proxy_listen my.remarkable.com
$proxy_listen internal.cloud.remarkable.com
$proxy_listen ping.remarkable.com
$proxy_listen webapp-prod.cloud.remarkable.engineering
EOF
}

# Remove all static host entries redirecting the cloud to the proxy
uninstall-hosts() {
    sed -i '/ hwr-production-dot-remarkable-production.appspot.com$/d' "$hosts_path"
    sed -i '/ service-manager-production-dot-remarkable-production.appspot.com$/d' "$hosts_path"
    sed -i '/ local.appspot.com$/d' "$hosts_path"
    sed -i '/ my.remarkable.com$/d' "$hosts_path"
    sed -i '/ internal.cloud.remarkable.com$/d' "$hosts_path"
    sed -i '/ ping.remarkable.com$/d' "$hosts_path"
    sed -i '/ webapp-prod.cloud.remarkable.engineering$/d' "$hosts_path"
}

# Try to make a full install of rmfakecloud-multiproxy
install() {
    # Generate and validate config first
    if [[ ! -e "$conf_dir/config" ]]; then
        generate-default-config
    fi
    validate-config
    # Start install process
    trap install-failed EXIT
    disconnect-cloud
    install-certificates
    install-hosts
    mark-enabled
    systemctl enable multiproxy.service
    systemctl restart multiproxy.service
    trap EXIT
}

install-failed() {
    echo "Install interrupted, trying to clean up"
    uninstall
}

# Disable and cleanup rmfakecloud-multiproxy
uninstall() {
    # Temporarily disable exit-on-error so as to clean up as much as possible
    set +e
    disconnect-cloud
    mark-disabled
    systemctl disable --now multiproxy.service
    uninstall-hosts
    uninstall-certificates
    set -e
}

help() {
    echo "Usage: $(basename "$0") COMMAND
Manage rmfakecloud-multiproxy. Available commands:

    help                    Show this help message.
    status                  Check the current status of rmfakecloud-multiproxy.
    enable                  Enable rmfakecloud-multiproxy.
    disable                 Disable rmfakecloud-multiproxy.
    set-config KEY VAL      Set configuration KEY to VAL.
    get-config [KEY]        Get all configuration, or just KEY.
    validate                Validate the config has no errors.

To view all config keys with documentation:

    rmfakecloud-multiproxy --docs

Some keys have shorthands:

    upstream                UPSTREAM_CLOUD_URL      (string)
    log                     LOG_HTTP_REQUESTS       (bool)
    passthrough             USE_OFFICIAL_CLOUD      (bool)"
}

resolve-config-shorthand() {
    case $1 in
    "upstream")
        echo "UPSTREAM_CLOUD_URL"
        ;;
    "log")
        echo "LOG_HTTP_REQUESTS"
        ;;
    "passthrough")
        echo "USE_OFFICIAL_CLOUD"
        ;;
    *)
        echo $1;
    esac
}

if [[ $0 = "${BASH_SOURCE[0]}" ]]; then
    if [[ $# -eq 0 ]]; then
        help
        exit 1
    fi

    action="$1"
    shift

    case $action in
        status)
            is-enabled && state="${green}enabled" || state="${red}disabled"
            service="$(systemctl is-active multiproxy.service)" || true

            if [[ $service = active ]]; then
                service="$green$service"
            else
                service="$yellow$service"
            fi

            echo -e "Status: $state$reset ($service$reset)"
            echo -en "Upstream server: "

            if ! upstream="$(get-config "UPSTREAM_CLOUD_URL")"; then
                echo -e "(${yellow}not set$reset)"
            else
                echo -en "$upstream (checking status...)"
                if ! upstream_status="$(check-upstream "$upstream")"; then
                    echo -en "\rUpstream server: $upstream "
                    echo -e "($red$upstream_status$reset)$clearline"
                else
                    echo -en "\rUpstream server: $upstream "
                    echo -e "($green$upstream_status$reset)$clearline"
                fi
            fi

            if is-enabled; then
                echo "Run \`multiproxyctl disable\` to disable rmfakecloud-multiproxy."
            else
                echo "Run \`multiproxyctl enable\` to enable rmfakecloud-multiproxy."
            fi

            echo "Run \`multiproxyctl set-config upstream https://<server>\` to set the upstream server."
            ;;

        enable)
            if is-enabled; then
                echo "rmfakecloud-multiproxy is already enabled."
            else
                install
                echo "rmfakecloud-multiproxy is now enabled."
            fi
            ;;

        disable)
            uninstall
            echo "rmfakecloud-multiproxy is now disabled."
            ;;

        set-config)
            if (($# < 1)); then
                echo "Missing config key argument"
                exit 1
            fi
            if (($# < 2)); then
                echo "Missing config value argument"
                exit 1
            fi

            key=$(resolve-config-shorthand $1)
            if [[ "$(get-config "$key")" == "$2" ]]; then
                echo "$key already set to '$2'."
            else
                disconnect-cloud
                set-config "$key" "$2"

                if is-enabled; then
                    systemctl restart multiproxy.service
                fi
            fi
            ;;

        get-config)
            if [[ $# -eq 0 ]]; then
                echo "# config dump $(date)"
                echo "# file: $conf_dir/config"
                sed '/^#/d; /^\s*$/d' "$conf_dir/config"
                exit 0
            fi

            key=$(resolve-config-shorthand "$1")
            if ! val=$(get-config "$key") ; then
                exit 1
            fi
            echo "$key=$val"
            ;;

        validate)
            validate-config
            ;;

        help | -h | --help)
            help
            ;;

        *)
            echo -e "Error: Invalid command '$action'\n"
            help
            exit 1
            ;;
    esac
fi
